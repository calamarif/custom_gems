import dataclasses
import importlib
import inspect
import json
import logging

from pyspark.sql.functions import expr
from pyspark.sql.types import StructType, StructField
from prophecy.cb.server.base.datatypes import SInt, SString, SFloat, SBoolean

from prophecy.cb.server.base.ComponentBuilderBase import SeverityLevelEnum, SelectStmt, DiagnosticType
from prophecy.cb.ui.SparkUtil import extractColumnName
from prophecy.cb.ui.uispec import PortSchemaTypeEnum, SColumn, SColumnExpression, SecretValue
from prophecy.cb.util.StringUtils import isBlank


class GenericJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        datacls = type(obj)
        ref = f"{datacls.__module__}.{datacls.__qualname__}"
        if isinstance(obj, SColumn):
            prop = {"_type": "Column", "format": obj.format}
            if obj.rawExpression is not None:
                prop["value"] = f'{obj.rawExpression}'
            return prop
        elif isinstance(obj, SInt):
            prop = {"_type": "SInt"}
            if obj.rawValue is not None:
                prop["rawValue"] = f'{obj.rawValue}'
            return prop
        elif isinstance(obj, SString):
            prop = {"_type": "SString"}
            if obj.rawValue is not None:
                prop["rawValue"] = f'{obj.rawValue}'
            return prop
        elif isinstance(obj, SFloat):
            prop = {"_type": "SFloat"}
            if obj.rawValue is not None:
                prop["rawValue"] = f'{obj.rawValue}'
            return prop
        elif isinstance(obj, SBoolean):
            prop = {"_type": "SBoolean"}
            if obj.rawValue is not None:
                prop["rawValue"] = f'{obj.rawValue}'
            return prop
        elif isinstance(obj, SecretValue):
            return {"_type": "SecretValue", "value": obj.jsonProperties()}
        elif isinstance(obj, StructType):
            return {"_type": "pyspark.sql.types.StructType", "value": obj.json()}
        elif isinstance(obj, PortSchemaTypeEnum):
            return {"_type": "PortSchemaTypeEnum", "value": obj.value}
        elif isinstance(obj, SeverityLevelEnum):
            return {"_type": "SeverityLevelEnum", "value": obj.value}
        elif isinstance(obj, SelectStmt):
            return json.dumps(obj, default=lambda o: o.__dict__, indent=4)
        elif isinstance(obj, DiagnosticType):
            return {"_type": "DiagnosticType", "value": obj.value}
        elif dataclasses.is_dataclass(datacls) or ref.startswith("prophecy.cb."):
            return {"_type": ref, "value": obj.__dict__}
        else:
            return super().default(obj)


class DialogJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        datacls = type(obj)
        if isinstance(obj, SColumn):
            return obj.jsonProperties()
        if isinstance(obj, SColumnExpression):
            return obj.jsonProperties()
        else:
            return obj.__dict__


class GenericJSONDecoder(json.JSONDecoder):

    def __init__(self, *args, **kwargs):
        self.extra_modules: dict = kwargs.pop('extra_modules', [])
        super().__init__(*args, object_hook=self.object_hook,
                         **kwargs)

    def _create_instance(sekf,datacls, payload):
        required_fields = inspect.signature(datacls.__init__).parameters.keys()
        required_fields_payload = {key: value for key, value in payload.items() if key in required_fields}
        return datacls(**required_fields_payload)

    def object_hook(self, obj):
        if '_type' not in obj:
            return obj
        return self.create_object(obj['_type'], obj)

    def create_object(self, type, obj):
        if type == 'Column':
            value = obj['value']
            langFormat = 'python'
            if 'format' in obj:
                langFormat = obj['format']
            usedColumns = []
            if 'usedColumns' in obj:
                usedColumns = obj['usedColumns']
            expression = None
            # Skipping expression evaluation since we don't use this in code anymore (Additional performance for calcuating it)
            # if not isBlank(value):
            #     # We'll supress any errors related to parsing as actual validation layer will throw correct error
            #     try:
            #         expression = expr(value)
            #     except:
            #         print(f"unable to parse expression {value}")
            #         expression = None
            diagnostics = None
            if 'diagnosticMessages' in obj:
                diagnostics = obj['diagnosticMessages']
            return SColumn(value, langFormat, expression, usedColumns, diagnostics)
        elif type == "SecretValue":
            return SecretValue.fromJson(obj['value'])
        elif type == "SInt" or type == "SString" or type == "SFloat" or type == "SBoolean":
            rawValue = obj['rawValue']
            langFormat = 'python'
            if 'format' in obj:
                langFormat = obj['format']
            value = None
            if 'value' in obj:
                value = obj['value']
            diagnostics = None
            if 'diagnosticMessages' in obj:
                diagnostics = obj['diagnosticMessages']
            wrapperObject = None
            if type == "SInt":
                wrapperObject = SInt(rawValue, langFormat, value, diagnostics)
            elif type == "SString":
                wrapperObject = SString(rawValue, langFormat, value, diagnostics)
            elif type == "SBoolean":
                wrapperObject = SBoolean(rawValue, langFormat, value, diagnostics)
            else:
                wrapperObject = SFloat(rawValue, langFormat, value, diagnostics)
            return wrapperObject


        elif type == "pyspark.sql.types.StructType":
            if obj['value'] is None:
                return None
            elif isinstance(obj['value'], str):
                return StructType.fromJson(json.loads(obj['value']))
            else:
                return StructType.fromJson(obj['value'])
        elif type == "pyspark.sql.types.StructField":
            if (isinstance(obj['value'], str)):
                return StructField.fromJson(json.loads(obj['value']))
            else:
                return StructField.fromJson(obj['value'])
        elif type == 'PortSchemaTypeEnum':
            return PortSchemaTypeEnum.getEnum(obj['value'])
        elif type == 'SeverityLevelEnum':
            return SeverityLevelEnum.getEnum(obj['value'])
        elif type == 'DiagnosticType':
            return DiagnosticType.getEnum(obj['value'])
        elif type.startswith("__main__"):
            fullName = type
            modname, hasdot, lastQualname = fullName.rpartition('.')
            modname, hasdot, firstQualname = modname.rpartition('.')
            if not isBlank(modname):
                module = importlib.import_module(modname)
                mainModule = getattr(module, firstQualname)
                if hasattr(mainModule, "_instance"):
                    mainModule = getattr(mainModule, "_instance")
            else:
                # This is a case in which a class directly in the gem spec is being accessed
                mainModule = importlib.import_module(firstQualname)
            datacls = getattr(mainModule, lastQualname)
            return self._create_instance(datacls, obj['value'])
        else:
            if (isinstance(type, str)):
                try:
                    modname, hasdot, qualname = type.rpartition('.')
                    module = importlib.import_module(modname)
                    datacls = getattr(module, qualname)
                    return self._create_instance(datacls, obj['value'])
                except:
                    package_parts = type.split(".")
                    if len(package_parts) > 1:
                        if package_parts[0] in self.extra_modules:
                            datatype = self.extra_modules.get(package_parts[0])
                        else:
                            datatype = importlib.import_module(package_parts[0])
                        for i in range(1, len(package_parts)):
                            datatype = getattr(datatype, package_parts[i])
                        return self._create_instance(datatype, obj['value'])
                    else:
                        datatype = getattr(__name__, package_parts[0])
                        return self._create_instance(datatype, obj['value'])
            else:
                return self._create_instance(type, obj['value'])
        return obj
