from abc import ABC, abstractmethod
from collections import defaultdict
from dataclasses import replace
from typing import *

from prophecy.cb.server.base.ComponentBuilderBase import Diagnostic, SeverityLevelEnum, NodeMetadata
from prophecy.cb.sql.Component import Component, MacroParameter, MacroProperties, PropertiesType, BasicMacroProperties
from prophecy.cb.sql.SqlContext import SqlContext, MacroDefFromSqlSource, DBTMacroType, MacroArgumentDef
from prophecy.cb.sql.providerTypes import ProviderTypeEnum
from prophecy.cb.ui.uispec import Dialog


class MacroCode(ABC):
    pass


class MacroSpec(ABC):
    @property
    @abstractmethod
    def name(self) -> str:
        pass

    @property
    @abstractmethod
    def projectName(self) -> str:
        return ""

    @property
    def category(self) -> str:
        return ""

    @property
    def priority(self) -> int:
        return 1800

    @property
    def minNumOfInputPorts(self) -> int:
        return 0

    @property
    def label(self) -> str:
        return self.name

    @property
    def optimizeCode(self) -> bool:
        return False

    @property
    def dependsOnUpstreamSchema(self) -> bool:
        return False

    @property
    def supportedProviderTypes(self) -> list[ProviderTypeEnum]:
        return [ProviderTypeEnum.BigQuery, ProviderTypeEnum.Snowflake, ProviderTypeEnum.Databricks,
                ProviderTypeEnum.Trino, ProviderTypeEnum.Redshift, ProviderTypeEnum.ProphecyManaged]

    @property
    @abstractmethod
    def dialog(self) -> Dialog:
        pass

    @classmethod
    def getMacroMap(cls, context: SqlContext) -> Dict[str, list[MacroDefFromSqlSource]]:
        macroProjectMap: Dict[str, list[MacroDefFromSqlSource]] = context.dependencyProjectMacros
        macroProjectMap[context.projectName] = context.projectMacros
        return macroProjectMap

    @classmethod
    def getMacro(cls, macroName: str, projectName: str, context: SqlContext) -> Optional[MacroDefFromSqlSource]:
        macroMap: Dict[str, list[MacroDefFromSqlSource]] = cls.getMacroMap(context)
        macroDef: Optional[MacroDefFromSqlSource] = {macroDef.name: macroDef for macroDef in
                                                     macroMap[projectName] if
                                                     macroDef.name == macroName}.get(macroName)
        return macroDef

    @classmethod
    def _isMacroParameters(self, parameter):
        hasName = hasattr(parameter, 'name')
        hasValue = hasattr(parameter, 'value')
        return hasName and hasValue

    @classmethod
    def _isDefaultMacroProperties(cls, properties):
        hasMacroName = hasattr(properties, 'macroName')
        hasProjectName = hasattr(properties, 'projectName')
        if hasattr(properties, 'parameters'):
            parameters = getattr(properties, 'parameters')
            if isinstance(parameters, list):
                hasParameters = all([cls._isMacroParameters(parameter) for parameter in parameters])
            else:
                hasParameters = False
        else:
            hasParameters = False
        return hasMacroName and hasProjectName and hasParameters

    def validate(self, context: SqlContext, component: Component) -> List[Diagnostic]:
        diagnostics = []
        if (self._isDefaultMacroProperties(component.properties)):
            if component.properties.macroName == "":
                diagnostics.append(Diagnostic(
                    "properties.macroName",
                    "Macro name cannot be empty",
                    SeverityLevelEnum.Error
                ))
            else:
                macroProjectMap: Dict[str, list[MacroDefFromSqlSource]] = self.getMacroMap(context)
                projectName = component.properties.projectName if component.properties.projectName != "" else context.projectName
                if projectName not in macroProjectMap:
                    diagnostics.append(Diagnostic(
                        "properties.projectName",
                        f"Project name {component.properties.projectName} doesn't exist. Current Project is ${context.projectName}",
                        SeverityLevelEnum.Error
                    ))
                else:
                    macroDef: Optional[MacroDefFromSqlSource] = self.getMacro(component.properties.macroName,
                                                                              projectName,
                                                                              context)
                    if macroDef is None:
                        diagnostics.append(Diagnostic(
                            "properties.macroName",
                            f"Macro {component.properties.macroName} doesn't exist",
                            SeverityLevelEnum.Error
                        ))
                    else:
                        if macroDef.macroType == DBTMacroType.Expression:
                            diagnostics.append(Diagnostic(
                                "properties.macroName",
                                f"Macro {component.properties.macroName} is an Expression Macro. Cannot be used as a Gem.",
                                SeverityLevelEnum.Error
                            ))
                        else:
                            paramsUserSelected = {parameter.name for parameter in component.properties.parameters}
                            for idx, argumentDef in enumerate(macroDef.parameters):
                                if argumentDef.name not in paramsUserSelected and argumentDef.defaultValue == "":
                                    diagnostics.append(Diagnostic(
                                        f"properties.parameters[{idx}].value",
                                        f"Parameter {argumentDef.name} must not be empty. As it doesn't contain a default value.",
                                        SeverityLevelEnum.Error
                                    )
                                    )
                    # TODO WIP: Jinja validation
        else:
            macroProjectMap: Dict[str, list[MacroDefFromSqlSource]] = self.getMacroMap(context)
            if self.projectName not in macroProjectMap:
                diagnostics.append(Diagnostic(
                    "",
                    f"Project name {self.projectName} doesn't exist. Current Project is ${context.projectName}",
                    SeverityLevelEnum.Error
                ))
            else:
                macroDef: Optional[MacroDefFromSqlSource] = self.getMacro(self.name,
                                                                          self.projectName,
                                                                          context)
                if macroDef is None:
                    diagnostics.append(Diagnostic(
                        "",
                        f"Macro {self.name} doesn't exist",
                        SeverityLevelEnum.Error
                    ))

        return diagnostics

    def updateParamValuesWithSlugs(self, processedParams: List[MacroParameter], availableSlugs: List[str],
                                   remainingMacroArgs: List[MacroArgumentDef]) -> List[MacroParameter]:
        if len(availableSlugs) == 0:
            remaining_params = [MacroParameter(arg.name, "") for arg in remainingMacroArgs]
            return processedParams + remaining_params
        if len(remainingMacroArgs) == 0:
            return processedParams
        nextArg = remainingMacroArgs[0]
        if nextArg.kind == "TableNameElement":
            processedParams.append(MacroParameter(nextArg.name, availableSlugs[0]))
            availableSlugs = availableSlugs[1:]
            remainingMacroArgs = remainingMacroArgs[1:]
        else:
            processedParams.append(MacroParameter(nextArg.name, ""))
            remainingMacroArgs = remainingMacroArgs[1:]
        return self.updateParamValuesWithSlugs(processedParams, availableSlugs, remainingMacroArgs)

    def onChange(self, context: SqlContext, oldState: Component, newState: Component) -> Component:
        if self._isDefaultMacroProperties(newState.properties) and self._isDefaultMacroProperties(oldState.properties):
            projectName = newState.properties.projectName if newState.properties.projectName != "" else context.projectName
            macroDef: Optional[MacroDefFromSqlSource] = self.getMacro(newState.properties.macroName, projectName,
                                                                      context)
            macroArgs = macroDef.parameters if macroDef is not None else []

            if oldState.properties.macroName != newState.properties.macroName or len(oldState.ports.inputs) != len(
                    newState.ports.inputs):
                parameters = self.updateParamValuesWithSlugs(processedParams=[],
                                                             availableSlugs=[x.slug for x in newState.ports.inputs],
                                                             remainingMacroArgs=macroArgs)
            else:
                parameters = newState.properties.parameters

            # TODO WIP Jinja validation and populate used macros

            return newState.bindProperties(replace(newState.properties, parameters=parameters))
        else:
            return newState

    def apply(self, props: MacroProperties) -> str:
        if self._isDefaultMacroProperties(props):
            non_empty_params = filter(lambda parameter: parameter.value != "", props.parameters)
            arguments = ','.join([f"{parameter.name} = {parameter.value}" for parameter in non_empty_params])
            if props.projectName != "":
                resolved_macro_name = f"{props.projectName}.{props.macroName}"
            else:
                resolved_macro_name = props.macroName
            return f'{{{{ {resolved_macro_name}({arguments}) }}}}'
        else:
            ''

    @property
    def userReadme(self) -> str:
        return ""

    @classmethod
    def updateInputPortSlug(cls, component: Component, context: SqlContext):
        if cls._isDefaultMacroProperties(component.properties):
            projectName = component.properties.projectName if component.properties.projectName != "" else context.projectName
            macroDef: Optional[MacroDefFromSqlSource] = cls.getMacro(component.properties.macroName, projectName,
                                                                     context)
            if macroDef is None:
                return component
            table_arguments: list[tuple[int, MacroArgumentDef]] = [(idx, argument) for (idx, argument) in
                                                                   enumerate(macroDef.parameters) if
                                                                   argument.kind == 'TableNameElement']
            upstreamProcessIds: list[str] = [connection.source for connection in context.graph.connections if
                                             connection.targetPort in [input.id for input in component.ports.inputs]]
            upstreamNodeMetadatas: list[Optional[NodeMetadata]] = [context.graph.nodes.get(upstreamProcessId) for
                                                                   upstreamProcessId in upstreamProcessIds]
            for argument_idx, argument in table_arguments:
                if argument_idx >= len(component.properties.parameters):
                    continue
                parameter = component.properties.parameters[argument_idx]
                inputSlug = None
                port_idx = None
                for idx, input in enumerate(component.ports.inputs):
                    if parameter.value == f"'{input.slug}'":  # parameter was not set to older slug
                        inputSlug = input
                        port_idx = idx
                        break
                if inputSlug is None:
                    continue
                upstreamNodeMetadata = upstreamNodeMetadatas[port_idx]
                if upstreamNodeMetadata is None or upstreamNodeMetadata.slug == '':
                    continue
                parameter.value = f"'{upstreamNodeMetadata.slug}'"
            for idx, upstreamNodeMetadata in enumerate(upstreamNodeMetadatas):
                if idx >= len(component.ports.inputs) or upstreamNodeMetadata.slug == '':
                    continue
                component.ports.inputs[idx] = replace(component.ports.inputs[idx], slug=upstreamNodeMetadata.slug)
        return component

    def convertToParameterMap(self, parameters: List[MacroParameter]):
        params = defaultdict(str)
        for parameter in parameters:
            params[parameter.name] = parameter.value
        return params

    def loadProperties(self, properties: MacroProperties) -> PropertiesType:
        return properties

    def unloadProperties(self, properties: PropertiesType) -> BasicMacroProperties:
        return BasicMacroProperties(macroName=self.name, projectName=self.projectName, parameters=[])
