from prophecy.cb.server.airflow.common import SettingsTab
from prophecy.cb.server.base.ComponentBuilderBase import (
    Component,
    ComponentCode,
    ComponentProperties,
    ComponentSpec,
    Diagnostic,
    SeverityLevelEnum,
)
from prophecy.cb.server.base.WorkflowContext import (
    WorkflowContext,
)
from prophecy.cb.ui.uispec import *
from prophecy.cb.util.StringUtils import isBlank


class SFTPToSnowflakeSpec(ComponentSpec):
    name: str = "SFTPToSnowflake"
    category: str = "Data Transfer"
    gemDescription: str = """This operator copies data from SFTP to Snowflake and creates a table"""

    @staticmethod
    def properties_tab():
        return (StackLayout(direction="vertical", width="30%", padding="1em")
        .addElement(
            StackItem(grow=1).addElement(
                StackLayout(direction="vertical", gap="20px", width="100%")
                .addElement(TitleElement("Source File Configuration"))
                .addElement(
                    SelectBox(
                        titleVar="*SFTP Connection",
                        placeholder="sftp_default",
                        helpText="The connection added in Prophecy for SFTP auth"
                    ).withHelpText("The connection added in Prophecy for SFTP auth")
                    .withSearchEnabled()
                    .withNoContentMessage(
                        "No Sftp Connection found in current fabric"
                    )
                    .bindProperty("sftp_conn_id")
                    .bindOptionProperty("${$.metadata.connections.sftp}")
                )
                .addElement(
                    TextBox("*SFTP File path",
                            placeholder="/sftp_user/customers_data/customer.csv").bindProperty(
                        "sftp_file_path"
                    )
                )
                .addElement(
                    SelectBox("*File Format")
                    .addOption("Csv", "CSV")
                    # .addOption("Excel", "EXCEL")
                    .bindProperty("file_format")
                )
                .addElement(
                    Condition()
                    .ifEqual(
                        PropExpr("component.properties.file_format"),
                        StringExpr("CSV"),
                    )
                    .then(
                        TextBox("*Column Delimiter", placeholder=",",
                                helpText="Field delimiter for CSV file").bindProperty(
                            "csv_field_delimiter",
                        )
                    )
                )
                .addElement(
                    Condition()
                    .ifEqual(
                        PropExpr("component.properties.file_format"),
                        StringExpr("CSV"),
                    )
                    .then(
                        SelectBox("*Header settings", placeholder="Default", helpText="CSV header settings")
                        .addOption("Default", "DEFAULT")
                        .addOption("Skip Header", "SKIP_HEADER")
                        .addOption("Parse Header", "PARSE_HEADER")
                        .bindProperty("csv_header_settings", )
                    ))
                .addElement(TitleElement("Target Snowflake Configuration"))
                .addElement(
                    SelectBox(
                        titleVar="*Snowflake Connection name",
                        placeholder="snowflake_default",
                    )
                    .withSearchEnabled()
                    .withNoContentMessage(
                        "No more Snowflake Connections found in current fabric"
                    )
                    .bindProperty("snowflake_conn_id")
                    .bindOptionProperty("${$.metadata.connections.snowflakedirect}")
                )
                .addElement(
                    TextBox("*Table name", placeholder="snowflake_table").bindProperty(
                        "snowflake_table"
                    )
                )
                .addElement(
                    SelectBox("*Write Mode", placeholder="Overwrite")
                    .addOption("Overwrite", "OVERWRITE")
                    .addOption("Append", "APPEND")
                    .bindProperty("write_mode", )
                )
            )))

    def dialog(self) -> Dialog:
        return Dialog("SFTP To Snowflake Operator").addElement(
            StackLayout(direction="horizontal").addElement(
                FieldPickerWithTabs("Properties")
                .addTab(
                    PickerTab("Gem Settings", "GemSettings", False, propertyVar="component.settings")
                    .addFields(SettingsTab.settings_field_picker().fields)
                )
            )
            .addElement(SFTPToSnowflakeSpec.properties_tab())
        )

    def optimizeCode(self) -> bool:
        return False  # TODO: make this work

    @dataclass(frozen=True)
    class SFTPToSnowflakeProperties(ComponentProperties):
        taskId: Optional[str] = None
        snowflake_conn_id: Optional[str] = None
        snowflake_table: Optional[str] = None
        write_mode: str = "OVERWRITE"

        sftp_conn_id: Optional[str] = None
        sftp_file_path: Optional[str] = None
        sftp_operation: str = "put"
        file_format: str = "CSV"

        # format specific
        csv_field_delimiter: str = ","
        csv_header_settings: str = "DEFAULT"

    def validate(
            self, context: WorkflowContext, component: Component[SFTPToSnowflakeProperties]
    ) -> List[Diagnostic]:
        diagnostics = []
        props = component.properties
        if isBlank(props.snowflake_conn_id):
            diagnostics.append(
                Diagnostic(
                    "properties.snowflake_conn_id",
                    "Choose an Snowflake airflow connection",
                    SeverityLevelEnum.Error,
                )
            )
        if isBlank(props.sftp_conn_id):
            diagnostics.append(
                Diagnostic(
                    "properties.sftp_conn_id",
                    "Choose an SFTP airflow connection",
                    SeverityLevelEnum.Error,
                )
            )
        return diagnostics

    def onChange(
            self,
            context: WorkflowContext,
            oldState: Component[SFTPToSnowflakeProperties],
            newState: Component[SFTPToSnowflakeProperties],
    ) -> Component[SFTPToSnowflakeProperties]:
        return newState

    class SFTPToSnowflakeCode(ComponentCode):
        def __init__(self, newProps, newSettings):
            self.props: SFTPToSnowflakeSpec.SFTPToSnowflakeProperties = newProps
            self.settings: dict = newSettings

        def apply(self):
            from airflow.operators.python import PythonOperator
            from airflow.providers.snowflake.hooks.snowflake import SnowflakeHook
            from airflow.providers.sftp.hooks.sftp import SFTPHook
            from pathlib import Path
            import datetime
            import os
            # sftp
            sftp_conn_id = self.props.sftp_conn_id
            sftp_file_path = self.props.sftp_file_path
            file_name = f"{os.path.basename(sftp_file_path)}_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"
            local_file_path = f"/tmp/{file_name}"  # download file to this path locally
            file_format = self.props.file_format
            # snowflake
            stage_name = "PROPHECY_AIRFLOW_SNOWFLAKE_TEMP_STAGE"
            format_name = "PROPHECY_AIRFLOW_SNOWFLAKE_TEMP_FORMAT"
            snowflake_file_path = f"@{stage_name}/{file_name}"
            table_name = self.props.snowflake_table
            snowflake_conn_id = self.props.snowflake_conn_id
            write_mode = self.props.write_mode
            # file props
            csv_field_delimiter = self.props.csv_field_delimiter
            if self.props.csv_header_settings == 'PARSE_HEADER':
                csv_header_settings = 'PARSE_HEADER = TRUE'
            elif self.props.csv_header_settings == 'SKIP_HEADER':
                csv_header_settings = 'SKIP_HEADER = 1'
            else:
                csv_header_settings = ''

            def run_query(cursor, query):
                print("Running: ", query)
                cursor.execute(query)
                output = cursor.fetchall()
                for row in output:
                    print(row)
                print("=" * 20)

            def download_data():
                sftp_hook = SFTPHook(ssh_conn_id=sftp_conn_id)
                local_folder = os.path.dirname(local_file_path)
                Path(local_folder).mkdir(parents=True, exist_ok=True)
                file_msg = f"downloading file from {sftp_file_path} to {local_file_path}"
                print("Starting to transfer %s", file_msg)
                sftp_hook.retrieve_file(sftp_file_path, local_file_path)
                print("Transfer complete")

            def upload_data():
                # csv properties
                queries = {
                    "create_stage": f"CREATE  TEMPORARY  STAGE IF NOT EXISTS {stage_name} ",
                    "copy_file": f"PUT file://{local_file_path} {snowflake_file_path}",
                    "create_file_format": f"CREATE TEMPORARY FILE FORMAT {format_name} TYPE = {file_format} FIELD_DELIMITER = '{csv_field_delimiter}' {csv_header_settings}",
                    "delete_table": f"""DROP TABLE IF EXISTS {table_name}""",
                    "truncate_table": f"""TRUNCATE TABLE IF EXISTS {table_name}""",
                    "create_table": f"""CREATE TABLE IF NOT EXISTS {table_name}
                                  USING TEMPLATE (
                                    SELECT ARRAY_AGG(OBJECT_CONSTRUCT('COLUMN_NAME',UPPER(COLUMN_NAME), 'TYPE',TYPE, 'NULLABLE', NULLABLE, 'EXPRESSION',EXPRESSION))
                                    FROM TABLE(
                                      INFER_SCHEMA(
                                        LOCATION=>'{snowflake_file_path}',
                                        FILE_FORMAT=>'{format_name}'
                                      )
                                    )
                                  )""",
                    "copy_data_to_table": f"""COPY INTO {table_name}
                        FROM {snowflake_file_path}
                        FILE_FORMAT = (FORMAT_NAME = '{format_name}')
                        {'MATCH_BY_COLUMN_NAME = CASE_INSENSITIVE' if csv_header_settings == 'PARSE_HEADER = TRUE' else ''}""",
                    "get_data": f"""SELECT * from {table_name}"""
                }
                snowflake_hook = SnowflakeHook(snowflake_conn_id)
                conn = snowflake_hook.get_conn()
                cur = conn.cursor()

                try:
                    # creating a temporary stage
                    run_query(cur, queries["create_stage"])
                    # creating a temporary file format
                    run_query(cur, queries["create_file_format"])
                    # copy file from local to snowflake
                    run_query(cur, queries["copy_file"])

                    # create table if not exists
                    run_query(cur, queries["create_table"])

                    if write_mode == "OVERWRITE":  # truncate table
                        run_query(cur, queries["truncate_table"])

                    # copy data from stage to table
                    run_query(cur, queries["copy_data_to_table"])
                    # show data
                    # run_query(cur, queries["get_data"])

                except Exception as e:
                    print("Exception occurred: ", e)
                    raise e
                finally:
                    # Close the cursor and connection
                    cur.close()
                    conn.close()

            def execute():
                download_data()
                upload_data()

            return PythonOperator(
                task_id=self.props.taskId,
                python_callable=execute,
                **self.settings
            )
