import enum
from abc import ABC, abstractmethod
from dataclasses import dataclass, field, replace
from functools import wraps
from typing import Optional, List, TypeVar, Generic
from pyspark.sql.types import StructType
from dataclasses_json import dataclass_json

from prophecy.cb.migration import PropertyMigration, PropertyMigrationObj
from prophecy.cb.server.base.WorkflowContext import WorkflowContext
from prophecy.cb.ui.uispec import Dialog


# spark = SparkSession.builder.master("local[*]").appName("init").getOrCreate()
# sc = spark.sparkContext

def add_method(cls):
    def decorator(func):
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            return func(self, *args, **kwargs)

        setattr(cls, func.__name__, wrapper)
        # Note we are not binding func, but wrapper which accepts self but does exactly the same as func
        return func  # returning func means func can still be used normally

    return decorator


@dataclass(frozen=True)
class NodePort:
    id: str
    slug: str
    schema: Optional[StructType] = None
    isStreaming: Optional[bool] = None
    dataExplorerProps: Optional[str] = None


@dataclass(frozen=True)
class NodePorts:
    inputs: List[NodePort] = field(default_factory=list)
    outputs: List[NodePort] = field(default_factory=list)
    selectedInputFields: List[str] = field(default_factory=list)
    isCustomOutputSchema: bool = False
    autoUpdateOnRun: bool = False


@dataclass(frozen=True)
class NodeConnection:
    id: str
    source: str
    sourcePort: str
    target: str
    targetPort: str


class ComponentProperties(ABC):
    pass


@dataclass_json
@dataclass(frozen=True)
class NodeMetadata:
    label: str
    slug: str
    x: float = 0
    y: float = 0
    language: str = "python"
    phase: int = 0
    cache: bool = False
    dataPreview: bool = False
    detailedStats: bool = False
    comment: Optional[str] = None
    passThrough: Optional[str] = None
    removalCondition: Optional[str] = None
    showRecordsCount: bool = False


class SeverityLevel(ABC):
    pass


@enum.unique
class SeverityLevelEnum(enum.Enum):
    Error = "Error"
    Warning = "Warning"
    Information = "Information"
    Hint = "Hint"
    Log = "Log"

    def getEnum(value):
        if value == "Error":
            return SeverityLevelEnum.Error
        elif value == "Warning":
            return SeverityLevelEnum.Warning
        elif value == "Information":
            return SeverityLevelEnum.Information
        elif value == "Hint":
            return SeverityLevelEnum.Hint
        else:
            return SeverityLevelEnum.Log


class DiagnosticFix(ABC):
    fixType: str


class CopilotDiagnosticFix(DiagnosticFix):
    fixType = "CopilotDiagnosticFix"
    copilotFixType: str

    def __init__(self, copilotFixType: str):
        self.copilotFixType = copilotFixType


class ValueDiagnosticFix(DiagnosticFix):
    fixType = "ValueDiagnosticFix"
    fixedValue: str

    def __init__(self, fixedValue: str):
        self.fixedValue = fixedValue


class DiagnosticType(enum.Enum):
    String = "String"
    Markdown = "Markdown"

    @classmethod
    def getEnum(cls, value: str) -> 'DiagnosticType':
        if value == cls.Markdown.value:
            return cls.Markdown
        return cls.String


@dataclass(frozen=True)
class Diagnostic:
    path: str
    message: str
    severity: SeverityLevelEnum
    diagnosticFix: Optional[DiagnosticFix] = None
    diagnosticType: Optional[DiagnosticType] = None

    def appendMessage(self, msg: str):
        return replace(self, message=f"{self.message} {msg}")

    def setDiagnosticFix(self, diagnosticFix: DiagnosticFix):
        return replace(self, diagnosticFix=diagnosticFix)


@dataclass(frozen=True)
class ProjectionExpression:
    targetName: Optional[str]
    expression: str


@dataclass(frozen=True)
class OrderByExpression:
    expression: str


@dataclass(frozen=True)
class AggregateExpression:
    targetName: Optional[str]
    expression: str


@dataclass(frozen=True)
class JoinExpression:
    table: str
    joinType: Optional[str] = None
    joinCondition: Optional[str] = None


@dataclass(frozen=True)
class SelectStmt:
    gemType: str
    projectionExpressions: List[ProjectionExpression] = field(default_factory=list)
    orderByExpressions: List[OrderByExpression] = field(default_factory=list)
    aggregateExpressions: List[AggregateExpression] = field(default_factory=list)
    joinExpressions: List[JoinExpression] = field(default_factory=list)


PropertiesType = TypeVar("PropertiesType", bound=ComponentProperties)


@dataclass(frozen=True)
class Component(Generic[PropertiesType]):
    id: str
    component: str
    metadata: NodeMetadata
    properties: PropertiesType
    ports: NodePorts = field(default_factory=NodePorts)
    group: Optional[str] = None
    settings: Optional[dict] = None

    def bindProperties(self, propertiesV: PropertiesType):
        return replace(self, properties=propertiesV)

    def bindPorts(self, ports: NodePorts):
        return replace(self, ports=ports)


class ComponentSpec(ABC):
    @property
    @abstractmethod
    def name(self) -> str:
        pass

    @property
    @abstractmethod
    def category(self) -> str:
        pass

    @property
    def docUrl(self) -> Optional[str]:
        return None

    @property
    def gemDescription(self) -> Optional[str]:
        return None

    @property
    def altProcessLabel(self) -> Optional[str]:
        return None

    @abstractmethod
    def dialog(self) -> Dialog:
        pass

    @abstractmethod
    def validate(self, context: WorkflowContext, component: Component) -> List[Diagnostic]:
        pass

    @abstractmethod
    def onChange(self, context: WorkflowContext, oldState: Component, newState: Component) -> Component:
        pass

    def optimizeCode(self) -> bool:
        pass

    def customOutputSchemaEnabled(self) -> bool:
        pass

    def allInputsRequired(self) -> bool:
        True

    def __init__(self):
        self._migrations: list[PropertyMigration] = []

    def registerPropertyEvolution(self, *newMigrations):
        for migration in newMigrations:
            self._migrations.append(migration)

    def latestMigrationNumber(self) -> int:
        if len(self._migrations) > 0:
            return max([x.migrationNumber() for x in self._migrations])
        else:
            return 0

    def migrateUp(self, oldComponent: Component, currentMigrationNumber: int) -> Component:
        newProperties = oldComponent.properties
        for idx, migration in enumerate(sorted(self._migrations, key=lambda x: x.migrationNumber())):
            if migration.migrationNumber() <= currentMigrationNumber:
                pass
            else:
                if isinstance(migration, PropertyMigrationObj):
                    newProperties = migration.up(newProperties)
        newComponent = oldComponent.bindProperties(newProperties)
        return newComponent

    def migrateDown(self, newComponent: Component, targetMigrationNumber: int) -> Component:
        oldProperties = newComponent.properties
        for idx, migration in enumerate(sorted(self._migrations, key=lambda x: x.migrationNumber(), reverse=True)):
            if migration.migrationNumber() <= targetMigrationNumber:
                pass
            else:
                if isinstance(migration, PropertyMigrationObj):
                    oldProperties = migration.down(oldProperties)
        oldComponent = newComponent.bindProperties(oldProperties)
        return oldComponent


class ComponentCode(ABC):
    pass


class SubstituteDisabled(ABC):
    pass


class PostSubstituteDisabled(ABC):
    pass
