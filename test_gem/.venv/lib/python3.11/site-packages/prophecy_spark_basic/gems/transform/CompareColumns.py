from prophecy.cb.server.base.ComponentBuilderBase import *
from pyspark.sql import *
from pyspark.sql.functions import *
import dataclasses

from prophecy.cb.server.base import WorkflowContext
from prophecy.cb.server.base.datatypes import SInt, SString
from prophecy.cb.ui.uispec import *

import dataclasses

class CompareColumns(ComponentSpec):
    name: str = "CompareColumns"
    category: str = "Join/Split"
    gemDescription: str = "Compare values of records across two dataframes"
    docUrl: str = "https://docs.prophecy.io/engineers/compare-columns/"

    def optimizeCode(self) -> bool:
        return True

    @dataclass(frozen=True)
    class CompareColumnsProperties(ComponentProperties):
        columnsSelector: List[str] = field(default_factory=list)
        idColumns: List[SColumn] = field(default_factory=list)
        columnName: str = "column_name"
        matchCount: str = "match_count"
        mismatchCount: str = "mismatch_count"
        mismatchExampleLeft: str = "mismatch_example_left"
        mismatchExampleRight: str = "mismatch_example_right"
        mismatchIdColumnPrefix: str = "mismatch_example_"
        activeTab: Optional[str] = "id_columns"

    def onClickFunc(self, portId: str, column: str, state: Component[CompareColumnsProperties]):
        state.properties.idColumns.append(SColumn(f"""col("{column}")"""))
        return state.bindProperties(dataclasses.replace(state.properties, idColumns=state.properties.idColumns))

    def dialog(self) -> Dialog:
        id_column_table = BasicTable(
            "Test",
            columns=[Column(
                "ID columns to retain",
                "expression",
                TextBox("", ignoreTitle=True)
            )]
        ).bindProperty("idColumns")

        return Dialog("Compare Columns") \
            .addElement(
            ColumnsLayout(gap="1rem", height="100%")
                .addColumn(
                Ports(
                    selectedFieldsProperty="columnsSelector",
                    singleColumnClickCallback=self.onClickFunc
                ), "content"
            ).addColumn(
                Tabs()
                    .bindProperty("activeTab")
                    .addTabPane(TabPane("Select Id Columns", "id_columns").addElement(id_column_table))
                    .addTabPane(
                    TabPane("Select Output Columns", "output_columns").addElement(
                        StackLayout(height="100%")
                            .addElement(
                            TextBox("Output Column Name")
                                .bindPlaceholder("column_name")
                                .bindProperty("columnName")
                        )
                            .addElement(
                            TextBox("Match Count Column Name")
                                .bindPlaceholder("match_count")
                                .bindProperty("matchCount")
                        )
                            .addElement(
                            TextBox("Mismatch Count Column Name")
                                .bindPlaceholder("mismatch_count")
                                .bindProperty("mismatchCount")
                        )
                            .addElement(
                            TextBox("Mismatch Example Left Column Name")
                                .bindPlaceholder("mismatch_example_left")
                                .bindProperty("mismatchExampleLeft")
                        )
                            .addElement(
                            TextBox("Mismatch Example Right Column Name")
                                .bindPlaceholder("mismatch_example_right")
                                .bindProperty("mismatchExampleRight")
                        )
                            .addElement(
                            TextBox("Mismatch Example ID Column Prefix")
                                .bindPlaceholder("mismatch_example_")
                                .bindProperty("mismatchIdColumnPrefix")
                        )
                    )
                ),
                "2fr"
            )
        )

    def validate(self, context: WorkflowContext, component: Component[CompareColumnsProperties]) -> List[Diagnostic]:
        diagnostics = []

        if len(component.ports.inputs) < 2:
            diagnostics.append(Diagnostic(
                "ports.inputs",
                "Input ports can't be less than two in CompareColumns transformation",
                SeverityLevelEnum.Error
            ))
        if not component.properties.idColumns:
            diagnostics.append(
                Diagnostic("properties.idColumns", "Must specify at least 1 ID column", SeverityLevelEnum.Error))

        if len(component.ports.inputs) == 2:
            left_fields = set((f.name, f.dataType) for f in component.ports.inputs[0].schema.fields)
            right_fields = set((f.name, f.dataType) for f in component.ports.inputs[1].schema.fields)

            if left_fields != right_fields:
                diagnostics.append(Diagnostic(
                    "ports.inputs",
                    "Input schema mismatch: Inputs must have the same schema",
                    SeverityLevelEnum.Error
                ))

            cols_dict = {}
            for f in component.ports.inputs[0].schema.fields:
                cols_dict[f.name] = cols_dict.get(f.name, 0) + 1
            duplicate_cols = [k for k, v in cols_dict.items() if v > 1]
            if duplicate_cols:
                diagnostics.append(Diagnostic(
                    "ports.inputs",
                    f"Input schema invalid: Input ports have same columns repeated - {', '.join(duplicate_cols)}",
                    SeverityLevelEnum.Error
                ))

        parameter_columns = [
            (component.properties.columnName, "properties.columnName"),
            (component.properties.matchCount, "properties.matchCount"),
            (component.properties.mismatchCount, "properties.mismatchCount"),
            (component.properties.mismatchExampleLeft, "properties.mismatchExampleLeft"),
            (component.properties.mismatchExampleRight, "properties.mismatchExampleRight")
        ]

        if len(set(t[0] for t in parameter_columns)) != len(parameter_columns):
            from collections import defaultdict
            dup_res = defaultdict(list)
            for k, v in parameter_columns:
                dup_res[k].append(v)
            for k, v in dup_res:
                if len(v) > 1:
                    diagnostics.append(
                        Diagnostic(k, f"Duplicate column name parameter: {k}", SeverityLevelEnum.Error))

        return diagnostics

    def onChange(self, context: WorkflowContext, oldState: Component[CompareColumnsProperties], newState: Component[CompareColumnsProperties]) -> Component[
        CompareColumnsProperties]:
        used_columns = []
        for p in newState.ports.inputs:
            used_columns.extend([f"{p.slug}##{col}"
                                 for sCol in newState.properties.idColumns
                                 for col in sCol.usedColumns])
        return newState.bindProperties(
            dataclasses.replace(
                newState.properties,
                columnsSelector=used_columns
            ))


    class CompareColumnsCode(ComponentCode):
        def __init__(self, newProps):
            self.props: CompareColumns.CompareColumnsProperties = newProps

        def apply(self, spark: SparkSession, in0: DataFrame, in1: DataFrame) -> DataFrame:
            from pyspark.sql.functions import lit, sum, first, explode_outer, create_map, when, coalesce, col, row_number
            from pyspark.sql.window import Window
            from functools import reduce

            idCols = [col(x.columnName()) for x in self.props.idColumns]
            idColumns = [x.columnName() for x in self.props.idColumns]

            columnName = self.props.columnName
            matchCount = self.props.matchCount
            mismatchCount = self.props.mismatchCount
            mismatchExampleLeft = self.props.mismatchExampleLeft
            mismatchExampleRight = self.props.mismatchExampleRight
            mismatchExampleIdPrefix = self.props.mismatchIdColumnPrefix

            df1, df2 = in0, in1
            (value, left_value, right_value, row_number_column_name) = (
                "##value##", "##left_value##", "##right_value##", "##row_number###")

            valueColumnsMap = []
            for vColumn in set(df1.columns).difference(set(idColumns)):
                valueColumnsMap.extend([lit(vColumn), col(vColumn).cast("string")])

            selectCols = idCols + [explode_outer(create_map(*valueColumnsMap)).alias(columnName, value)]

            exploded1 = df1.select(*selectCols).alias("exploded1")
            exploded2 = df2.select(*selectCols).alias("exploded2")

            joinCols = [columnName] + idColumns
            joinOutputCols = [coalesce(col(f"exploded1.{c}"), col(f"exploded2.{c}")).alias(c.replace("`", "")) for c in joinCols] + [
                col(f"exploded1.{value}").alias(left_value),
                col(f"exploded2.{value}").alias(right_value)
            ]
            join_predicate = reduce(lambda a, c: a & c,
                                    [col(f"exploded1.{c}") == col(f"exploded2.{c}") for c in joinCols], lit(True))
            joined = exploded1.join(exploded2, join_predicate, "full_outer") \
                .select(*joinOutputCols) \
                .withColumn(matchCount, when(
                coalesce(col(left_value) == col(right_value), col(left_value).isNull() & col(right_value).isNull()),
                lit(1)).otherwise(lit(0))) \
                .withColumn(mismatchCount, when(coalesce(col(left_value) != col(right_value), ~ (
                    col(left_value).isNull() & col(right_value).isNull())), lit(1)).otherwise(lit(0)))

            joinSparkCols = [col(c) for c in joinCols]
            windowSpec = Window.partitionBy(*joinSparkCols).orderBy(*idCols)
            exampleCols = joinSparkCols + [
                lit(0).alias(matchCount),
                lit(0).alias(mismatchCount),
                col(left_value).alias(mismatchExampleLeft),
                col(right_value).alias(mismatchExampleRight)
            ]
            mismatchExamples = joined \
                .filter(col(mismatchCount).__gt__(lit(0))) \
                .withColumn(row_number_column_name, row_number().over(windowSpec)) \
                .filter(col(row_number_column_name) == lit(1)) \
                .select(*exampleCols) \
                .dropDuplicates([columnName])
            aggColumns = [
                sum(matchCount).alias(matchCount),
                sum(mismatchCount).alias(mismatchCount),
                first(col(mismatchExampleLeft), ignorenulls=True).alias(mismatchExampleLeft),
                first(col(mismatchExampleRight), ignorenulls=True).alias(mismatchExampleRight)
            ]
            aggColumns += [first(when(
                coalesce(col(mismatchExampleLeft), col(mismatchExampleRight)).isNotNull(), col(c)
            ).otherwise(lit(None)), ignorenulls=True).alias(mismatchExampleIdPrefix + c) for c in idColumns]
            return joined \
                .drop(left_value) \
                .drop(right_value) \
                .withColumn(mismatchExampleLeft, lit(None)) \
                .withColumn(mismatchExampleRight, lit(None)) \
                .union(mismatchExamples) \
                .groupBy(columnName) \
                .agg(*aggColumns) \
                .orderBy(col(mismatchCount).desc(), col(columnName))
