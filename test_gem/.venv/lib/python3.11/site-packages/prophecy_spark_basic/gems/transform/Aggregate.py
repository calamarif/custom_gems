from pyspark.sql import *
from pyspark.sql.functions import *
import dataclasses

from prophecy.cb.server.base.ComponentBuilderBase import *
from prophecy.cb.ui.UISpecUtil import (
    getColumnsToHighlight,
    SchemaFields,
    getColumnsInSchema,
    validateExpTable,
    ColumnsUsage,
    validateSColumn,
    sanitizedColumn,
)
from prophecy.cb.ui.uispec import *
from prophecy.cb.server.base import WorkflowContext
from prophecy.cb.util.CSVUtils import parse_escaped_csv, unparse_escaped_csv, CSVParseException

@dataclass(frozen=True)
class StringColName:
    colName: str


class Aggregate(ComponentSpec):
    name: str = "Aggregate"
    category: str = "Transform"
    gemDescription: str = "Performs a Group-by and Aggregate Operation"
    docUrl: str = "https://docs.prophecy.io/engineers/aggregate/"

    def optimizeCode(self) -> bool:
        return True

    @dataclass(frozen=True)
    class AggregateProperties(ComponentProperties):
        activeTab: str = "aggregate"
        columnsSelector: List[str] = field(default_factory=list)
        groupBy: List[SColumnExpression] = field(default_factory=list)
        aggregate: List[SColumnExpression] = field(default_factory=list)
        doPivot: bool = False
        pivotColumn: Optional[SColumn] = None
        pivotValues: List[StringColName] = field(default_factory=list)
        allowSelection: Optional[bool] = True
        allIns: Optional[bool] = False
        importString: str = ""
        importLanguage: str = "${$.workflow.metainfo.frontEndLanguage}"

    def onClickFunc(
            self, portId: str, column: str, state: Component[AggregateProperties]
    ):
        if state.properties.activeTab == "groupBy":
            groupbys = state.properties.groupBy
            groupbys.append(
                SColumnExpression.getSColumnExpression(sanitizedColumn(column))
            )
            return state.bindProperties(
                dataclasses.replace(state.properties, groupBy=groupbys, allowSelection=True)
            )
        elif state.properties.activeTab == "aggregate":
            aggregates = state.properties.aggregate
            aggregates.append(
                SColumnExpression(
                    column,
                    SColumn(
                        f"""first(col("{sanitizedColumn(column)}"))""",
                        "python",
                        first(col(f"{sanitizedColumn(column)}")),
                        [column],
                    ),
                )
            )
            return state.bindProperties(
                dataclasses.replace(state.properties, aggregate=aggregates, allowSelection=True)
            )
        else:
            return state.bindProperties(dataclasses.replace(state.properties, allowSelection=False))

    def allColumnsSelectionFunc(
            self, portId: str, state: Component[AggregateProperties]
    ):
        columnsInSchema = getColumnsInSchema(portId, state, SchemaFields.TopLevel)
        res = state
        for c in columnsInSchema:
            res = self.onClickFunc(portId, c, state)
        return res

    def dialog(self) -> Dialog:
        return Dialog("Aggregate").addElement(
            ColumnsLayout(gap="1rem", height="100%")
                .addColumn(
                Ports(
                    selectedFieldsProperty="columnsSelector",
                    singleColumnClickCallback=self.onClickFunc,
                    allColumnsSelectionCallback=self.allColumnsSelectionFunc,
                )
                    .allowColumnClickBasedOn("allowSelection"),
                "content",
                    )
                .addColumn(
                Tabs()
                    .bindProperty("activeTab")
                    .addTabPane(
                    TabPane("Aggregate", "aggregate").addElement(
                        StackLayout(height="100%")
                            .addElement(
                            ExpTable("Aggregate Expressions").bindProperty("aggregate").withCopilotEnabledExpressions().allowCopilotExpressionsFix()
                        )
                            .addElement(
                            ColumnsLayout().addColumn(
                                Checkbox("Propagate all input columns").bindProperty(
                                    "allIns"
                                )
                            )
                        )
                    )
                )
                    .addTabPane(
                    TabPane("Group By", "groupBy").addElement(
                        ExpTable("Group By Columns").bindProperty("groupBy")
                    )
                )
                    .addTabPane(
                    TabPane("Pivot", "pivot")
                        .addElement(Checkbox("Do pivot").bindProperty("doPivot"))
                        .addElement(
                        Condition()
                            .ifEqual(
                            PropExpr("component.properties.doPivot"), BooleanExpr(True)
                        )
                            .then(
                            StackLayout(gap="1rem")
                                .addElement(
                                ExpressionBox("Pivot Column")
                                    .makeFieldOptional()
                                    .withSchemaSuggestions()
                                    .bindPlaceholders(
                                    {
                                        "scala": """col("col_name")""",
                                        "python": """col("col_name")""",
                                        "sql": """col_name""",
                                    }
                                )
                                    .bindProperty("pivotColumn")
                            )
                                .addElement(
                                BasicTable(
                                    "Unique Values",
                                    height="400px",
                                    columns=[
                                        Column(
                                            "Unique Values",
                                            "colName",
                                            (
                                                TextBox("").bindPlaceholder(
                                                    "Enter value present in pivot column"
                                                )
                                            ),
                                        )
                                    ],
                                ).bindProperty("pivotValues")
                            )
                        )
                    )
                )
                    .addTabPane(
                    TabPane("Advanced", "advanced")
                    .addElement(
                        AlertBox(
                            variant="success",
                            _children=[
                                Markdown(
                                    "**How to Save Advanced Expressions?**\n\n\n"
                                    "âœ… Please switch to **groupBy/aggregate/pivot** tab to save the expressions"
                                )
                            ]
                        )
                    )                    
                    .addElement(
                        StackLayout(height="100%") \
                            .addElement(
                            NativeText("Edit the Aggregate expressions in the field below. Use the format of \"(groupby|aggregate|pivotcol|pivotvalues),(name|value),(expr)\".")
                        ).addElement(
                            NativeText("Use ``...`` to wrap multi-line expressions.")
                        ).addElement(
                            Editor(height="100%", language="${component.properties.importLanguage}") \
                                .bindProperty("importString")
                        )
                    )
                ),
                "5fr",
                    )
        ).withCopilotEnabledAutoSuggestionProperties()

    def tf_to_csv(self, state: Component[AggregateProperties]) -> Component[AggregateProperties]:
        tfs = []

        for tf in state.properties.aggregate:
            linepart = ["aggregate", tf.target, tf.expression.rawExpression]
            tfs.append(linepart)

        for tf in state.properties.groupBy:
            linepart = ["groupby", tf.target, tf.expression.rawExpression]
            tfs.append(linepart)

        if state.properties.doPivot:
            if state.properties.pivotColumn is not None:
                # tfs.append(["pivotcol", state.properties.pivotColumn.columnName()])
                tfs.append(["pivotcol", state.properties.pivotColumn.rawExpression])
                if len(state.properties.pivotValues)!=0:
                    for x in state.properties.pivotValues:
                        linepart = ["pivotvalues", x.colName]
                        tfs.append(linepart)

        csv_string = unparse_escaped_csv(tfs)
        return state.bindProperties(dataclasses.replace(state.properties, importString=csv_string))

    def csv_to_tf(self, state: Component[AggregateProperties]) -> Component[AggregateProperties]:
        tfs = []
        ilang = state.properties.importLanguage
        group_by = []
        aggregate = []
        pivot_col = None
        pivot_values = []
        doPivot = False
        for line in parse_escaped_csv(state.properties.importString, field_min=2, field_max=3):
            tf_type = line[0].lower().strip()
            if tf_type == "groupby":
                (target, exp) = line[1:]
                group_by.append(SColumnExpression(
                    target.strip(),
                    SColumn(
                        exp,
                        state.properties.importLanguage,
                        expr(exp),
                        [exp]
                    ),
                    ""
                ))
            elif tf_type == "aggregate":
                (target, exp) = line[1:]
                aggregate.append(SColumnExpression(
                    target.strip(),
                    SColumn(
                        exp,
                        state.properties.importLanguage,
                        expr(exp),
                        [exp]
                    ),
                    ""
                ))
            elif tf_type == "pivotcol":
                doPivot = True
                target = line[1].strip()
                pivot_col = SColumn(target, "sql", col(sanitizedColumn(target)))
            elif tf_type == "pivotvalues":
                target = line[1].strip()
                pivot_values.append(StringColName(target))


        return state.bindProperties(dataclasses.replace(state.properties, groupBy=group_by, aggregate=aggregate, doPivot=doPivot,  pivotColumn=pivot_col, pivotValues=pivot_values))

    def validate(self, context: WorkflowContext, component: Component[AggregateProperties]) -> List[Diagnostic]:
        diagnostics = []
        if len(component.properties.aggregate) == 0:
            diagnostics.append(
                Diagnostic(
                    "properties.aggregate",
                    "At least one aggregate expression is required in Aggregate.",
                    SeverityLevelEnum.Error,
                )
            )
        else:
            # validate aggregate tab
            aggregateTabDiagnostics = validateExpTable(
                component.properties.aggregate, "aggregate", component
            )
            diagnostics += [x.appendMessage("[Aggregate]").setDiagnosticFix(CopilotDiagnosticFix("expression")) for x in aggregateTabDiagnostics]

            # validate groupby tab
            _d2 = validateExpTable(component.properties.groupBy, "groupBy", component)
            d2 = map(lambda x: x.appendMessage("[GroupBy]"), _d2)
            diagnostics.extend(d2)

            # validate pivot tab
            if component.properties.doPivot:
                if len(component.properties.groupBy) == 0:
                    diagnostics.append(
                        Diagnostic(
                            "properties.pivotColumn.expression",
                            "Pivot operation is only supported with groupBy operation. Please fill groupBy columns.",
                            SeverityLevelEnum.Error,
                        )
                    )

                elif component.properties.pivotColumn is not None:
                    d3 = [
                        d.appendMessage("[Pivot]")
                        for d in validateSColumn(
                            component.properties.pivotColumn,
                            "pivotColumn",
                            component,
                            testColumnPresence=ColumnsUsage.WithoutInputAlias,
                        )
                    ]

                    diagnostics.extend(d3)

                    if len(component.properties.pivotValues) > 0:
                        for idx, pivotVal in enumerate(
                                component.properties.pivotValues
                        ):
                            if len(pivotVal.colName.strip()) == 0:
                                diagnostics.append(
                                    Diagnostic(
                                        f"properties.pivotValues[{idx}].colName",
                                        "Row cannot be empty. [Pivot]",
                                        SeverityLevelEnum.Error,
                                    )
                                )
                else:
                    diagnostics.append(
                        Diagnostic(
                            "properties.pivotColumn.expression",
                            "Pivot column cannot be empty. [Pivot]",
                            SeverityLevelEnum.Error,
                        )
                    )

            if component.properties.activeTab == "advanced":
                try:
                    for (idx, line) in enumerate(parse_escaped_csv(component.properties.importString, field_min=2, field_max=3)):
                        tf_type = line[0].lower()
                        rest_count = len(line[1:])
                        msg = None
                        allowed_tfs = ["groupby", "aggregate", "pivotcol", "pivotvalues"]
                        if tf_type not in allowed_tfs:
                            msg = f"Unknown operation '{tf_type}'. Acceptable values are 'groupby', 'aggregate', 'pivotcol', and 'pivotvalues'."
                        elif tf_type == "groupby" and rest_count != 2:
                            msg = f"'Group By' takes 2 arguments (target, expression), got {rest_count}"
                        elif tf_type == "aggregate" and rest_count != 2:
                            msg = f"'Aggregate' takes 2 arguments (target, expression), got {rest_count}"
                        elif tf_type == "pivotcol" and rest_count != 1:
                            msg = f"'Pivot Column' takes 1 argument (column name), got {rest_count}"
                        elif tf_type == "pivotvalues" and rest_count != 1:
                            msg = f"'Pivot Values' takes 1 argument (value), got {rest_count}"


                        if msg is not None:
                            diagnostics.append(Diagnostic(f"properties.importString", msg, SeverityLevelEnum.Error))
                except CSVParseException as e:
                    diagnostics.append(Diagnostic(f"properties.importString", str(e), SeverityLevelEnum.Error))
        return diagnostics

    def getCPStmt(self, component: Component[AggregateProperties]) -> Optional[SelectStmt]:
        aggregateExpressions = [AggregateExpression(expression.target, expression.expression.rawExpression) for
                                expression in component.properties.groupBy]
        projectionExpressions = [ProjectionExpression(expression.target, expression.expression.rawExpression) for
                                 expression in component.properties.aggregate]
        return SelectStmt(
            component.component,
            projectionExpressions=projectionExpressions,
            aggregateExpressions=aggregateExpressions
        )

    def onChange(
            self,
            context: WorkflowContext,
            oldState: Component[AggregateProperties],
            newState: Component[AggregateProperties],
    ) -> Component[AggregateProperties]:
        oldProps = oldState.properties
        newProps = newState.properties

        if oldProps.activeTab == "advanced" and newProps.activeTab in ["groupBy", "aggregate", "pivot"]:
            try:
                newState = self.csv_to_tf(newState)
                newProps = newState.properties
            except CSVParseException:
                pass
        elif oldProps.activeTab in ["groupBy", "aggregate", "pivot"] and newProps.activeTab == "advanced":
            newState = self.tf_to_csv(newState)
            newProps = newState.properties


        used = getColumnsToHighlight(newProps.groupBy + newProps.aggregate, newState)
        if not newProps.doPivot:
            updatedPivotCol = None
            updatedPivotValues = newProps.pivotValues
        else:
            updatedPivotCol = newProps.pivotColumn
            updatedPivotValues = newProps.pivotValues

        updatedGroupBy = newProps.groupBy
        updatedAggregate = newProps.aggregate


        return newState.bindProperties(
            dataclasses.replace(
                newProps,
                columnsSelector=used,
                groupBy = updatedGroupBy,
                aggregate = updatedAggregate,
                activeTab=newProps.activeTab,
                pivotColumn=updatedPivotCol,
                pivotValues=updatedPivotValues,
                allowSelection=newProps.activeTab != "pivot",
            )
        )

    class AggregateCode(ComponentCode):
        def __init__(self, newProps):
            self.props: Aggregate.AggregateProperties = newProps

        def apply(self, spark: SparkSession, in0: DataFrame) -> DataFrame:
            additional_passthrough = []
            if self.props.allIns:
                agg_cols = [e.target for e in self.props.aggregate]
                groupBy_cols = [e.target for e in self.props.groupBy]
                pivot_cols = (
                    [self.props.pivotColumn.columnName()] if self.props.doPivot else []
                )
                additional_passthrough = [
                    first(col(x)).alias(x)
                    for x in in0.columns
                    if x not in (agg_cols + groupBy_cols + pivot_cols)
                ]

            if len(self.props.groupBy) == 0:
                foo = map(lambda x: x.column(), self.props.aggregate)
                out = in0.agg(*foo, *additional_passthrough)

            else:
                foo1 = map(lambda x: x.column(), self.props.groupBy)
                grouped = in0.groupBy(*foo1)
                if self.props.doPivot:
                    if self.props.pivotColumn is not None:
                        if len(self.props.pivotValues) == 0:
                            pivoted = grouped.pivot(self.props.pivotColumn.columnName())
                        else:  # (len(self.props.pivotValues)>0)
                            pivoted = grouped.pivot(
                                self.props.pivotColumn.columnName(),
                                [x.colName for x in self.props.pivotValues]
                            )
                    else:
                        pivoted = grouped
                else:
                    pivoted = grouped

                foo2 = map(lambda x: x.column(), self.props.aggregate)
                out = pivoted.agg(*foo2, *additional_passthrough)

            return out
