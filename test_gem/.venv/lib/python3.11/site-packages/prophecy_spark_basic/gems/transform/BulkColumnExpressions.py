from prophecy.cb.server.base.ComponentBuilderBase import *
from pyspark.sql import *
from pyspark.sql.functions import *

from prophecy.cb.server.base import WorkflowContext
from prophecy.cb.server.base.datatypes import SInt, SString
from prophecy.cb.ui.uispec import *
from pyspark.sql.types import StringType, BinaryType, BooleanType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, TimestampType, DateType
from pyspark.sql.types import StructType
import dataclasses

class BulkColumnExpressions(ComponentSpec):
    name: str = "BulkColumnExpressions"
    category: str = "Transform"
    docUrl: str = "https://docs.prophecy.io/engineers/bulk-column-expressions/"

    def optimizeCode(self) -> bool:
        return True

    @dataclass(frozen=True)
    class BulkColumnExpressionsProperties(ComponentProperties):
        columnNames: List[str] = field(default_factory=list)
        schema: Optional[StructType] = StructType([])
        dataType: str = ""
        prefixSuffixOption: str = "Prefix / Suffix to be added"
        prefixSuffixToBeAdded: str = ""
        castOutputTypeName: str = "Select output type"
        changeOutputFieldName: Optional[bool] = False
        changeOutputFieldType: Optional[bool] = False
        copyOriginalColumns: Optional[bool] = False
        expressionToBeApplied: str = ""
        isPrefix: Optional[bool] = False

    def dialog(self) -> Dialog:
        # Define the UI dialog structure for the component
        typeNames = ["StringType","BinaryType","BooleanType","ByteType","ShortType","IntegerType","LongType","FloatType","DoubleType", "DateType", "TimestampType"]
        dataTypeSelectBox = SelectBox("Data Type of the columns to do operations on").addOption("String Type", "String").addOption("Numeric Type", "Numeric").addOption("Date/Timestamp Type", "Date").addOption("All Types", "All").bindProperty("dataType")
        prefixSuffixDropDown = SelectBox("Add Prefix / Suffix").addOption("Prefix", "Prefix").addOption("Suffix", "Suffix").bindProperty("prefixSuffixOption")
        sparkDataTypeList = SelectBox("Cast output column as")
        for typeName in typeNames:
            sparkDataTypeList = sparkDataTypeList.addOption(typeName, typeName)
        sparkDataTypeList = sparkDataTypeList.bindProperty("castOutputTypeName")


        dialog = Dialog("BulkColumnExpressions").addElement(ColumnsLayout(gap="1rem", height="100%") \
        .addColumn(Ports(), "content") \
        .addColumn(StackLayout(height="100%").addElement(dataTypeSelectBox) \
        .addElement(SchemaColumnsDropdown("Selected Columns").withMultipleSelection().bindSchema("schema").bindProperty("columnNames")) \
        .addElement(Checkbox("Change output column name").bindProperty("changeOutputFieldName")) \
        .addElement(Condition().ifEqual(PropExpr("component.properties.changeOutputFieldName"), BooleanExpr(True)).then(StackLayout(gap="1rem").addElement(prefixSuffixDropDown).addElement(TextBox("Value").bindPlaceholder("Example: new_").bindProperty("prefixSuffixToBeAdded")).addElement(Checkbox("Copy incoming columns to output").bindProperty("copyOriginalColumns")))) \
        .addElement(Checkbox("Change output column type").bindProperty("changeOutputFieldType")) \
        .addElement(Condition().ifEqual(PropExpr("component.properties.changeOutputFieldType"), BooleanExpr(True)).then(ColumnsLayout().addColumn(sparkDataTypeList))) \
        .addElement(ExpressionBox("Output Expression").bindProperty("expressionToBeApplied").bindPlaceholder("Write spark sql expression considering `column_value` as column value and `column_name` as column name string literal. Example:\nFor column value: column_value * 100\nFor column name: upper(column_name)").bindLanguage("plaintext"))))
        return dialog

    def validate(self, context: WorkflowContext, component: Component[BulkColumnExpressionsProperties]) -> List[Diagnostic]:
        # Validate the component's state
        outputTypePlaceholderValue = "Select output type"
        prefixSuffixPlaceholderValue = "Prefix / Suffix to be added"
        dataTypeOfColumnsPlaceholderValue = ""
        diagnostics = []

        if component.properties.dataType == dataTypeOfColumnsPlaceholderValue:
            diagnostics.append(Diagnostic("properties.dataType","Please choose a valid input data type",SeverityLevelEnum.Error))
        else:
            if component.properties.columnNames is None or len(component.properties.columnNames) == 0:
                diagnostics.append(Diagnostic(
                    "properties.columnNames",
                    "At least one column needs to be selected",
                    SeverityLevelEnum.Error
                ))

            if not component.properties.expressionToBeApplied:
                diagnostics.append(Diagnostic(
                    "properties.expressionToBeApplied",
                    "Expression to be applied cannot be empty",
                    SeverityLevelEnum.Error
                ))

            if component.properties.changeOutputFieldName and not component.properties.prefixSuffixToBeAdded:
                diagnostics.append(Diagnostic(
                    "properties.prefixSuffixToBeAdded",
                    "Prefix / Suffix value cannot be empty",
                    SeverityLevelEnum.Error
                ))

            if component.properties.changeOutputFieldName and component.properties.prefixSuffixOption == prefixSuffixPlaceholderValue:
                diagnostics.append(Diagnostic(
                    "properties.prefixSuffixOption",
                    "Please choose a valid option for prefix / suffix",
                    SeverityLevelEnum.Error
                ))

        if component.properties.changeOutputFieldType and component.properties.castOutputTypeName == outputTypePlaceholderValue:
            diagnostics.append(Diagnostic(
                "properties.castOutputTypeName",
                "Please choose a valid output spark type",
                SeverityLevelEnum.Error
            ))

        return diagnostics

    def onChange(self, context: WorkflowContext, oldState: Component[BulkColumnExpressionsProperties], newState: Component[BulkColumnExpressionsProperties]) -> Component[
    BulkColumnExpressionsProperties]:
        # Handle changes in the component's state and return the new state
        dataTypeMapping = {
            "String": {StringType},
            "Numeric": {ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType},
            "Date": {DateType, TimestampType},
            "All": {StringType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DateType, TimestampType}
        }
        if newState.properties.dataType in dataTypeMapping:
            selectedDataTypes = set(dataTypeMapping[newState.properties.dataType])
        else:
            selectedDataTypes = set()

        if len(newState.ports.inputs) == 1 and newState.ports.inputs[0].schema is not None and newState.ports.inputs[0].schema.fields is not None:
            newSchema = [field for field in newState.ports.inputs[0].schema.fields if field.dataType.typeName in [k.typeName for k in selectedDataTypes]]
        else:
            newSchema = []
        prefix = newState.properties.prefixSuffixOption == "Prefix"
        
        newProperties = dataclasses.replace(dataclasses.replace(newState.properties, schema=StructType(newSchema)), isPrefix=prefix)

        return newState.bindProperties(newProperties)


    class BulkColumnExpressionsCode(ComponentCode):
        def __init__(self, newProps):
            self.props: BulkColumnExpressions.BulkColumnExpressionsProperties = newProps

        def apply(self, spark: SparkSession, in0: DataFrame) -> DataFrame:
            from pyspark.sql.functions import col, expr
            
            all_expressions = []
            
            # Extract all properties outside the loop to avoid schema analysis issues
            selected_columns = self.props.columnNames
            change_output_name = self.props.changeOutputFieldName
            is_prefix = self.props.isPrefix
            prefix_suffix_value = self.props.prefixSuffixToBeAdded
            change_output_type = self.props.changeOutputFieldType
            cast_type_name = self.props.castOutputTypeName
            copy_original = self.props.copyOriginalColumns
            expression_template = self.props.expressionToBeApplied
            
            # Convert to set for faster lookup
            selected_columns_set = set(selected_columns)
            
            # Iterate through in0.columns to maintain original sequence
            for column_name in in0.columns:
                if column_name in selected_columns_set:
                    # This column is selected for transformation
                    
                    # Build alias based on configuration
                    if change_output_name:
                        if is_prefix:
                            alias = prefix_suffix_value + column_name
                        else:  # Suffix
                            alias = column_name + prefix_suffix_value
                    else:
                        alias = column_name
                    
                    # Create the expression by replacing placeholders
                    expression = expression_template.replace("column_value", "`" + column_name + "`").replace("column_name", "'" + column_name + "'")
                    col_expr = expr(expression)
                    
                    # Apply type casting if needed
                    if change_output_type:
                        cast_type = StringType()  # Default
                        if cast_type_name == "StringType":
                            cast_type = StringType()
                        elif cast_type_name == "BinaryType":
                            cast_type = BinaryType()
                        elif cast_type_name == "BooleanType":
                            cast_type = BooleanType()
                        elif cast_type_name == "ByteType":
                            cast_type = ByteType()
                        elif cast_type_name == "ShortType":
                            cast_type = ShortType()
                        elif cast_type_name == "IntegerType":
                            cast_type = IntegerType()
                        elif cast_type_name == "LongType":
                            cast_type = LongType()
                        elif cast_type_name == "FloatType":
                            cast_type = FloatType()
                        elif cast_type_name == "DoubleType":
                            cast_type = DoubleType()
                        elif cast_type_name == "TimestampType":
                            cast_type = TimestampType()
                        elif cast_type_name == "DateType":
                            cast_type = DateType()
                        
                        col_expr = col_expr.cast(cast_type)
                    
                    # Add the transformed column
                    all_expressions.append(col_expr.alias(alias))
                    
                    # Add original column if copyOriginalColumns is enabled
                    if copy_original and change_output_name:
                        all_expressions.append(col("`" + column_name + "`"))
                        
                else:
                    # This column is not selected, keep as-is
                    all_expressions.append(col("`" + column_name + "`"))
            
            return in0.select(*all_expressions)