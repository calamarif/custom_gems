from prophecy.cb.server.base.ComponentBuilderBase import *
from pyspark.sql import *
from pyspark.sql.functions import *
import dataclasses

from prophecy.cb.server.base import WorkflowContext
from prophecy.cb.server.base.datatypes import SInt, SString
from prophecy.cb.ui.uispec import *


class SampleRows(ComponentSpec):
    name: str = "SampleRows"
    category: str = "Transform"
    gem_description: str = "Samples Rows based on certain conditions"
    docUrl: str = "https://docs.prophecy.io/engineers/sample-rows/"

    def optimizeCode(self) -> bool:
        # Return whether code optimization is enabled for this component
        return True

    @dataclass(frozen=True)
    class SampleRowsProperties(ComponentProperties):
        # properties for the component with default values
        sampling_ratio: str = "0.5"
        with_replacement: bool = False
        seed: Optional[str] = None
        sampling_strategy: Optional[str] = "percR"

    def dialog(self) -> Dialog:
        # Define the UI dialog structure for the component
        return Dialog("SampleRows").addElement(
            ColumnsLayout(gap = "1rem", height = "100%")
                .addColumn(Ports(), "content")
                .addColumn(
                StackLayout(gap = "1rem")
                    .addElement(
                    RadioGroup("Select Sampling Strategy")
                        .addOption("Number of records", "numR")
                        .addOption("Percentage of records", "percR")
                        .bindProperty("sampling_strategy")
                ).addElement(Condition()
                             .ifEqual(PropExpr("component.properties.sampling_strategy"), StringExpr("percR"))
                             .then(TextBox("Sampling Ratio (Double value between 0 and 1)")
                                   .bindPlaceholder("0.5")
                                   .bindProperty("sampling_ratio")).otherwise(TextBox("Sampling Ratio (Exact number of records to be selected )")
                                                                              .bindPlaceholder("10")
                                                                              .bindProperty("sampling_ratio")))
                    .addElement(
                    TextBox("Random seed for sampling (optional)")
                        .bindPlaceholder("long")
                        .bindProperty("seed")
                ).addElement(Condition()
                             .ifEqual(PropExpr("component.properties.sampling_strategy"), StringExpr("percR"))
                             .then(Checkbox("With Replacement")
                                   .bindProperty("with_replacement"))),
                "5fr"
            )
        )

    def validate(self, context: WorkflowContext, component: Component[SampleRowsProperties]) -> List[Diagnostic]:
        # Validate the component's state
        diagnostics = []

        if component.properties.sampling_strategy is not None:
            if component.properties.sampling_strategy == "percR":
                if component.properties.sampling_ratio is not None and component.properties.sampling_ratio != "" and not component.properties.sampling_ratio.replace(".", "").isdigit():
                    diagnostics.append(Diagnostic(
                        "properties.sampling_ratio",
                        "Sampling ratio has to be double",
                        SeverityLevelEnum.Error
                    ))
                elif component.properties.sampling_ratio is not None and component.properties.sampling_ratio != "" and float(component.properties.sampling_ratio) > 1:
                    diagnostics.append(Diagnostic(
                        "properties.sampling_ratio",
                        "Sampling ratio must be in the range [0, 1] without replacement",
                        SeverityLevelEnum.Error
                    ))
            else:
                if component.properties.sampling_ratio is not None and component.properties.sampling_ratio != "" and not component.properties.sampling_ratio.isdigit():
                    diagnostics.append(Diagnostic(
                        "properties.sampling_ratio",
                        "Sampling ratio has to be an integer between [0, (2**31)-1]",
                        SeverityLevelEnum.Error
                    ))
                elif component.properties.sampling_ratio is not None and component.properties.sampling_ratio != "" and int(component.properties.sampling_ratio) < 0:
                    diagnostics.append(Diagnostic(
                        "properties.sampling_ratio",
                        "Sampling ratio has to be an integer greater than 0.",
                        SeverityLevelEnum.Error
                    ))

            if (component.properties.seed is not None and component.properties.seed != "" and not (component.properties.seed.isdigit())):
                diagnostics.append(Diagnostic(
                    "properties.seed",
                    "Seed has to be an integer between [0, (2**31)-1]",
                    SeverityLevelEnum.Error
                ))

        return diagnostics

    def onChange(self, context: WorkflowContext, oldState: Component[SampleRowsProperties], newState: Component[SampleRowsProperties]) -> Component[
        SampleRowsProperties]:

        # Handle changes in the component's state and return the new state
        return newState


    class SampleRowsCode(ComponentCode):
        def __init__(self, newProps):
            self.props: SampleRows.SampleRowsProperties = newProps

        def apply(self, spark: SparkSession, in0: DataFrame) -> DataFrame:
            # This method contains logic used to generate the spark code from the given inputs.
            sampling_ratio = None

            if (self.props.sampling_strategy is not None and self.props.sampling_strategy == "numR"):
                import random
                totalRows: SubstituteDisabled = in0.count()

                if self.props.sampling_ratio is None or self.props.sampling_ratio == "":
                    sampling_ratio = "5"
                else:
                    sampling_ratio = self.props.sampling_ratio

                if totalRows == 0 or totalRows <= int(sampling_ratio):
                    return in0

                seed = int(self.props.seed) if (self.props.seed is not None and self.props.seed != "") else random.randint(1, totalRows)

                # 1. Order by all columns to ensure a consistent row order
                columns_ordered = in0.columns
                df_ordered = in0.orderBy(*columns_ordered)

                # 2. Generate row numbers in this ordered DataFrame
                windowSpec = Window.orderBy(*columns_ordered)
                df_with_row_num = df_ordered.withColumn("row_num", row_number().over(windowSpec))

                # 3. Use a hashing function combined with the seed on the row number
                # to create a "deterministic random" value, then order by this value
                hash_column_name = sha2(concat(col("row_num"), lit(str(seed))), 256)
                df_hashed = df_with_row_num.withColumn("hash_val", hash_column_name)
                df_hashed_ordered = df_hashed.orderBy("hash_val")

                # Directly taking n rows based on this deterministic hash ordering
                df_n_random_rows = df_hashed_ordered.limit(int(sampling_ratio))

                # Drop the auxiliary columns before returning the result
                final_df = df_n_random_rows.drop("row_num", "hash_val")

                return final_df

            else:
                if self.props.seed is not None and self.props.seed != "":
                    return in0.sample(
                        withReplacement=self.props.with_replacement,
                        fraction=float(self.props.sampling_ratio),
                        seed=int(self.props.seed)
                    )
                else:
                    return in0.sample(
                        withReplacement=self.props.with_replacement,
                        fraction=float(self.props.sampling_ratio)
                    )